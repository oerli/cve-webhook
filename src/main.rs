// #![feature(drain_filter)]

mod vulniq;

use std::{fs::File, io::Write, io::Read, collections::HashSet};

use structopt::StructOpt;

use serde::{Serialize, Deserialize};

use tera::{Tera, Context};
use reqwest::{ClientBuilder, StatusCode};

use chrono::Utc;

use crate::vulniq::{Vulnerability, Score};

#[derive(Deserialize, Debug)]
struct Webhook {
    url: String,
    days: i64,
    published: i64,
    template: String,
    vulniq_baerer_token: String,
}

#[derive(Serialize, Debug)]
struct Stats {
    count: i32,
    score: u8,
}

#[derive(Debug, Deserialize)]
pub struct Application {
    pub name: String,
    pub vendor: String,
    pub product: String,
    #[serde(skip_deserializing)]
    pub vulnerabilities: Vec<Vulnerability>,
    
}

#[derive(Debug, StructOpt)]
#[structopt(name = "cve-webhook", about = "Get specific Vulnerability informations and sends them to a Microsoft Teams Channel.")]
struct Opt {
    #[structopt(default_value = "./cfg/webhook.yaml", short, long, help = "Webhook configuration.")]
    webhook: String,

    #[structopt(default_value = "./cfg/applications.yaml", short, long, help = "List of Product and Vendors numbers.")]
    applications: String,

    #[structopt(short, long, help = "List of CVE numbers to be ignored and updated with newly found CVE numbers.")]
    ignore: Option<String>,

    #[structopt(default_value = "0", short, long, help = "Minimum Score, all below will be ignored.")]
    minimum_score: u8,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // read parameters
    let args = Opt::from_args();

    // read webhook configuration
    let mut buffer = String::new();
    File::open(&args.webhook)?.read_to_string(&mut buffer)?;
    let config: Webhook = serde_yaml::from_str(&buffer)?;

    // load ignore list or create empty one
    let mut ignore_list: HashSet<String> = match &args.ignore {
        Some(path) => {
            let mut buffer = String::new();
            File::open(path)?.read_to_string(&mut buffer)?;
            serde_yaml::from_str(&buffer)?
        },
        None => HashSet::new()
    };

    // read items list
    let mut buffer = String::new();
    File::open(&args.applications)?.read_to_string(&mut buffer)?;
    let mut applications: Vec<Application> = serde_yaml::from_str(&buffer)?;

    // items.update().await?;

    let now = Utc::now().naive_utc();

    let mut results: Vec<(String, Vec<Vulnerability>)> = Vec::new();

    // let mut results: HashMap<String, Vec<Vulnerability>> = HashMap::new();

    let mut stats = Stats {
        count: 0,
        score: 0
    };

    for application in applications {

        //debug
        println!("{:?}", application);

        match application.query(&config.vulniq_baerer_token).await{
            //TODO: inefficient cloning data
            // Ok(v) => results.append(&mut v.clone()),
            Ok(vulneraibilities) => results.push((application.name, vulneraibilities.into_iter().filter(|vulnerability| {
                // check for days past (updated)

                println!("{}", now.signed_duration_since(vulnerability.lastUpdatedAtSource).num_days());
                println!("{}", now.signed_duration_since(vulnerability.createDateAtSource).num_days());
                if now.signed_duration_since(vulnerability.lastUpdatedAtSource).num_days() <= config.days &&
                    // check for days past (created/published)
                    now.signed_duration_since(vulnerability.createDateAtSource).num_days() <= config.published &&
                    // minimum score reached
                    vulnerability.dataScore as u8 >= args.minimum_score &&
                    // not in ignore list 
                    !ignore_list.contains(&vulnerability.name) {
                        stats.score = (vulnerability.dataScore as u8).max(stats.score);
                        stats.count = stats.count + 1;
                        true
                } else {
                    false
                }
            }).collect())),
            Err(e) => println!("{}", e),
        }


        
    }

    let tera_engine = Tera::new("templates/*.tera")?;

    let mut context = Context::new();

    // do not send empty lists
    if stats.count > 0 {
        context.insert("stats", &stats);
        context.insert("results", &results);

        let data = tera_engine.render(&config.template, &context).unwrap();

        let client = ClientBuilder::new().cookie_store(true).build()?;
        // send webhook data
        let response = client.post(config.url).header("Content-Type","application/json").body(data).send().await?;

        match response.status() {
            StatusCode::OK | StatusCode::CREATED | StatusCode::ACCEPTED => {
                match &args.ignore {
                    // add all sent vulnerabilities to ignore list
                    Some(path) => {
                        for (_name, vulnerabilities) in results {
                            for vulnerability in vulnerabilities {
                                ignore_list.insert(vulnerability.name);
                            }
                        }

                        // write updated ignore list
                        let mut buffer = String::new();
                        buffer = serde_yaml::to_string(&ignore_list)?;

                        File::create(path)?.write_all(&mut buffer.as_bytes())?;
                    },
                    None => ()
                }
            },
            _ => ()
        }
    }

    Ok(())
}
