#![feature(drain_filter)]

mod cvedb;

use std::fs::File;
use std::io::Read;

// use std::io::prelude::*;

use structopt::StructOpt;

use serde::{Serialize, Deserialize};

use tera::{Tera, Context};
use reqwest::ClientBuilder;

use chrono::Utc;

use crate::cvedb::{CveConfig, CveConfigType, Cve};

#[derive(Deserialize, Debug)]
struct Webhook {
    url: String,
    days: i64,
    template: String,
}

#[derive(Serialize, Debug)]
struct Stats {
    product_count: i32,
    vendor_count: i32,
    product_score: f32,
    vendor_score: f32,
    count: i32,
    score: f32,
}

#[derive(Debug, StructOpt)]
#[structopt(name = "cve-webhook", about = "Get specific Vulnerability informations and sends them to a Microsoft Teams Channel.")]
struct Opt {
    #[structopt(default_value = "./cfg/webhook.yaml", short, long, help = "Specify the log output directory, the directory will be created if it does not exist. Each logfile will be created with hostname and timestamp.")]
    webhook: String,

    #[structopt(default_value = "./cfg/cvedb.yaml", short, long, help = "Specify the log output directory, the directory will be created if it does not exist. Each logfile will be created with hostname and timestamp.")]
    cvedb: String,
}

// TODO's:
// - add docs/readme/comments
// - monthly report
// - usee whole structs for template instead of tuple
// - check if persitent storage must be used

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // read parameters
    let args = Opt::from_args();

    let mut buffer = String::new();
    File::open(&args.webhook)?.read_to_string(&mut buffer)?;
    let config: Webhook = serde_yaml::from_str(&buffer)?;

    let mut cvedb = CveConfig::new(&args.cvedb).await?;

    cvedb.update().await?;

    let now = Utc::today().naive_utc();

    let mut results: Vec<(String, Vec<Cve>)> = Vec::new();

    let mut stats = Stats {
        product_count: 0,
        vendor_count: 0,
        product_score: 0.,
        vendor_score: 0.,
        count: 0,
        score: 0.
    };

    for list in cvedb.items {
        match list {
            CveConfigType::Product(product) => {
                match product.cve {
                    Some(items) => {
                        results.push((product.product, items.into_iter().filter(|cve| {
                            if now.signed_duration_since(cve.update_date).num_days() <= config.days {
                                stats.product_score = cve.cvss_score.max(stats.product_score);
                                stats.product_count = stats.product_count + 1;
                                true
                            } else {
                                false
                            }
                        }).collect()));
                    },
                    None => {}
                }
                
            },
            CveConfigType::Vendor(vendor) => {

                match vendor.cve {
                    Some(items) => {
                        results.push((vendor.vendor, items.into_iter().filter(|cve| {
                            if now.signed_duration_since(cve.update_date).num_days() <= config.days {
                                stats.vendor_score = cve.cvss_score.max(stats.vendor_score);
                                stats.vendor_count = stats.vendor_count + 1;
                                true
                            } else {
                                false
                            }
                        }).collect()));
                    },
                    None => {}
                }
                
            }
        }
    }

    // workaround remove entries with empty cve list
    // nightly feature
    results.drain_filter(|(_name, cve)| cve.is_empty());
    
    stats.score = stats.product_score.max(stats.vendor_score);
    stats.count = stats.product_count + stats.vendor_count;
    

    let tera_engine = Tera::new("templates/*.tera")?;

    let mut context = Context::new();

    // do not send empty lists
    if stats.count > 0 {
        context.insert("stats", &stats);
        context.insert("results", &results);

        let data = tera_engine.render(&config.template, &context).unwrap();

        // let mut file = File::create("output.json")?;
        // file.write_all(data.as_bytes())?;

        let client = ClientBuilder::new().cookie_store(true).build()?;
        let response = client.post(config.url).header("Content-Type","application/json").body(data).send().await?;
        // println!("{:#?}", response);
    }

    Ok(())
}
