#![feature(drain_filter)]

mod cvedb;

use std::{fs::File, io::Write, io::Read};

use structopt::StructOpt;

use serde::{Serialize, Deserialize};

use tera::{Tera, Context};
use reqwest::ClientBuilder;

use chrono::Utc;

use std::collections::HashSet;

use crate::cvedb::{CveConfig, CveConfigType, Cve};

#[derive(Deserialize, Debug)]
struct Webhook {
    url: String,
    days: i64,
    template: String,
}

#[derive(Serialize, Debug)]
struct Stats {
    product_count: i32,
    vendor_count: i32,
    product_score: f32,
    vendor_score: f32,
    count: i32,
    score: f32,
}

#[derive(Debug, StructOpt)]
#[structopt(name = "cve-webhook", about = "Get specific Vulnerability informations and sends them to a Microsoft Teams Channel.")]
struct Opt {
    #[structopt(default_value = "./cfg/webhook.yaml", short, long, help = "Webhook configuration.")]
    webhook: String,

    #[structopt(default_value = "./cfg/cvedb.yaml", short, long, help = "List of Product and Vendors numbers.")]
    cvedb: String,

    #[structopt(short, long, help = "List of CVE numbers to be ignored and updated with newly found CVE numbers.")]
    ignore: Option<String>,

    #[structopt(default_value = "0.", short, long, help = "Minimum Score, all below will be ignored.")]
    score: f32,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // read parameters
    let args = Opt::from_args();

    let mut buffer = String::new();
    File::open(&args.webhook)?.read_to_string(&mut buffer)?;
    let config: Webhook = serde_yaml::from_str(&buffer)?;

    // load ignore list or create empty one
    let mut ignore_list: HashSet<String> = match &args.ignore {
        Some(path) => {
            let mut buffer = String::new();
            File::open(path)?.read_to_string(&mut buffer)?;
            serde_yaml::from_str(&buffer)?
        },
        None => HashSet::new()
    };    

    let mut cvedb = CveConfig::new(&args.cvedb).await?;

    cvedb.update().await?;

    let now = Utc::today().naive_utc();

    let mut results: Vec<(String, Vec<Cve>)> = Vec::new();

    let mut stats = Stats {
        product_count: 0,
        vendor_count: 0,
        product_score: 0.,
        vendor_score: 0.,
        count: 0,
        score: 0.
    };

    for list in cvedb.items {
        match list {
            CveConfigType::Product(product) => {
                match product.cve {
                    Some(items) => {
                        results.push((product.product, items.into_iter().filter(|cve| {      
                            // check for days past
                            if now.signed_duration_since(cve.update_date).num_days() <= config.days &&
                                // minimum score reached
                                cve.cvss_score >= args.score &&
                                // not in ignore list 
                                !ignore_list.contains(&cve.cve_id) {
                                    stats.product_score = cve.cvss_score.max(stats.product_score);
                                    stats.product_count = stats.product_count + 1;
                                    true
                            } else {
                                false
                            }
                        }).collect()));
                    },
                    None => {}
                }
                
            },
            CveConfigType::Vendor(vendor) => {

                match vendor.cve {
                    Some(items) => {
                        results.push((vendor.vendor, items.into_iter().filter(|cve| {
                            // check for days past
                            if now.signed_duration_since(cve.update_date).num_days() <= config.days &&
                                // minimum score reached
                                cve.cvss_score >= args.score &&
                                // not in ignore list 
                                !ignore_list.contains(&cve.cve_id) {
                                    stats.vendor_score = cve.cvss_score.max(stats.vendor_score);
                                    stats.vendor_count = stats.vendor_count + 1;
                                    true
                            } else {
                                false
                            }
                        }).collect()));
                    },
                    None => {}
                }
                
            }
        }
    }

    // workaround remove entries with empty cve list
    // nightly feature
    results.drain_filter(|(_name, cve)| cve.is_empty());
    
    stats.score = stats.product_score.max(stats.vendor_score);
    stats.count = stats.product_count + stats.vendor_count;
    

    let tera_engine = Tera::new("templates/*.tera")?;

    let mut context = Context::new();

    // do not send empty lists
    if stats.count > 0 {
        context.insert("stats", &stats);
        context.insert("results", &results);

        let data = tera_engine.render(&config.template, &context).unwrap();

        let client = ClientBuilder::new().cookie_store(true).build()?;
        let _response = client.post(config.url).header("Content-Type","application/json").body(data).send().await?;
    }

    // add all already sent cves to ignore list
    match &args.ignore {
        Some(path) => {
            for (_name, cves) in results {
                for cve in cves {
                    ignore_list.insert(cve.cve_id);
                }
            }

            let mut buffer = String::new();
            buffer = serde_yaml::to_string(&ignore_list)?;

            File::create(path)?.write_all(&mut buffer.as_bytes())?;
        },
        None => ()
    }

    Ok(())
}
