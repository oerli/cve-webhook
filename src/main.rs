mod cvedb;

use std::fs::File;
use std::io::Read;

use serde::{Serialize, Deserialize};

use tera::{Tera, Context};
use reqwest::ClientBuilder;

use chrono::Utc;

use crate::cvedb::{CveConfig, CveConfigType, Cve};

#[derive(Deserialize, Debug)]
struct Webhook {
    url: String,
    days: i64,
    template: String,
}

#[derive(Serialize, Debug)]
struct Stats {
    product_count: i32,
    vendor_count: i32,
    product_score: f32,
    vendor_score: f32,
    count: i32,
    score: f32,
}

// TODO's:
// - config as parameter
// - add docs/readme/comments
// - monthly report
// - usee whole structs for template instead of tuple

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {

    let mut buffer = String::new();
    File::open("./cfg/webhook.yaml")?.read_to_string(&mut buffer)?;
    let config: Webhook = serde_yaml::from_str(&buffer)?;

    let mut cvedb = CveConfig::new("./cfg/cvedb.yaml").await?;

    cvedb.update().await?;

    let now = Utc::today().naive_utc();

    let mut results: Vec<(String, Vec<Cve>)> = Vec::new();

    let mut stats = Stats {
        product_count: 0,
        vendor_count: 0,
        product_score: 0.,
        vendor_score: 0.,
        count: 0,
        score: 0.
    };

    for list in cvedb.items {
        match list {
            CveConfigType::Product(product) => {
                match product.cve {
                    Some(items) => {
                        results.push((product.product, items.into_iter().filter(|cve| {
                            if now.signed_duration_since(cve.update_date).num_days() < config.days {
                                stats.product_score = cve.cvss_score.max(stats.product_score);
                                stats.product_count = stats.product_count + 1;
                                true
                            } else {
                                false
                            }
                        }).collect()));
                    },
                    None => {}
                }
                
            },
            CveConfigType::Vendor(vendor) => {

                match vendor.cve {
                    Some(items) => {
                        results.push((vendor.vendor, items.into_iter().filter(|cve| {
                            if now.signed_duration_since(cve.update_date).num_days() < config.days {
                                stats.vendor_score = cve.cvss_score.max(stats.vendor_score);
                                stats.vendor_count = stats.vendor_count + 1;
                                true
                            } else {
                                false
                            }
                        }).collect()));
                    },
                    None => {}
                }
                
            }
        }
    }

    stats.score = stats.product_score.max(stats.vendor_score);
    stats.count = stats.product_count + stats.vendor_count;
    

    let tera_engine = Tera::new("templates/*.tera")?;

    let mut context = Context::new();

    // do not send empty lists
    if stats.count > 0 {
        context.insert("stats", &stats);
        context.insert("results", &results);

        let data = tera_engine.render(&config.template, &context).unwrap();

        let client = ClientBuilder::new().cookie_store(true).build()?;
        client.post(config.url).header("Content-Type","application/json").body(data).send().await?;
    }

    Ok(())
}
