mod cvedb;

use std::fs::File;
use std::io::Read;

use serde::Deserialize;

use tera::{Tera, Context};
use reqwest::ClientBuilder;

use chrono::Utc;

use crate::cvedb::{CveDB, CveResult};

#[derive(Deserialize, Debug)]
struct Webhook {
    url: String,
    days: i64,
}

// TODO's:
// - async not yet used
// - add docs/readme/comments

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {

    let mut buffer = String::new();
    File::open("./cfg/webhook.yaml")?.read_to_string(&mut buffer)?;
    let config: Webhook = serde_yaml::from_str(&buffer)?;

    let mut cvedb = CveDB::new("./cfg/cvedb.yaml").await?;
    cvedb.update().await?;

    let tera_engine = Tera::new("templates/*.tera")?;

    let mut context = Context::new();
    
    let now = Utc::today().naive_utc();

    let mut cve_result_list = Vec::new();
    
    let mut publish_count = 0;
    let mut update_count = 0;
    let mut max_score = 0.;

    for product in cvedb.results {
        let mut cve_list = Vec::new();
        for cve in product.list {
            if now.signed_duration_since(cve.update_date).num_days() < config.days {
                if cve.publish_date.eq(&cve.update_date) {
                    publish_count = publish_count + 1;
                } else {
                    update_count = update_count + 1;
                }

                if max_score < cve.cvss_score {
                    max_score = cve.cvss_score;
                }

                cve_list.push(cve);                
            }
        }

        if cve_list.len() > 0 {
            cve_result_list.push(CveResult{
                config: product.config,
                list: cve_list
            });
        }
    }
    
    context.insert("products", &cve_result_list);
    context.insert("publish_count", &publish_count);
    context.insert("update_count", &update_count);
    context.insert("max_score", &max_score);

    let data = tera_engine.render("messagecard.json.tera", &context).unwrap();
    
    let client = ClientBuilder::new().cookie_store(true).build()?;
    let _ = client.post(config.url).header("Content-Type","application/json").body(data).send().await?;
    
    Ok(())
}
